'From Squeak4.2 of 4 February 2011 [latest update: #10966] on 4 April 2011 at 4:38:59 pm'!"Change Set:		HTTPSocketPatch-muDate:			4 April 2011Author:			Masashi UmezawaRemoved redundant 'User-Agent:' header. "!!HTTPSocket class methodsFor: 'get the page' stamp: 'mu 4/4/2011 16:30'!httpRequest: method url: urlString headers: hdrs content: contentOrNil response: responseBlock	"Sends an HTTP request to the server. Returns a MIMEDocument if successful,	a string indicating the error otherwise. If a response block is provided, the	response is fed into into so that the sender can see all the headers.	The url string is assumed to be properly escaped by the sender."	| index serverAndPort server port rawUrl stream resp code headers 	  contentLength contentType contentStream |	(urlString beginsWith: 'http://') ifFalse:[self error: 'Not a http url'].	"Extract server, port, and url"	index := urlString indexOf: $/ startingAt: 8 ifAbsent:[urlString size+1]. "past http://"	serverAndPort := urlString copyFrom: 8 to: index-1.	server := serverAndPort copyUpTo: $:.	port := ((serverAndPort copyAfter: $:) ifEmpty:['80']) asNumber.	"Prepare the request URI"	rawUrl := urlString copyFrom: index to: urlString size.	(rawUrl beginsWith: '/') ifFalse:[rawUrl := '/', rawUrl].	"Check for proxy"	(self shouldUseProxy: server) ifTrue:[		self httpProxyServer ifNotEmpty:[			rawUrl := 'http://', serverAndPort, rawUrl. "per RFC 2616"			server := self httpProxyServer.			port := self httpProxyPort.		].	].	"Fire off the request"	stream := SocketStream openConnectionToHostNamed: server port: port.	stream nextPutAll: method; space; nextPutAll: rawUrl; space; nextPutAll: 'HTTP/1.1'; crlf.	stream nextPutAll: 'Host: ', serverAndPort; crlf.	stream nextPutAll: 'Connection: close'; crlf.	stream nextPutAll: self userAgentString; crlf.	stream nextPutAll: hdrs.	stream crlf.	contentOrNil ifNotNil:[		"Upload request content"		contentStream := contentOrNil readStream.		[contentStream atEnd] whileFalse:[			(HTTPProgress new) total: contentOrNil size; 				amount: contentStream position; signal: 'Uploading...'.			stream nextPutAll: (contentStream next: 4096).			stream flush.		].	].	stream flush.	"Read the response"	resp := stream upToAll: String crlfcrlf.	"Extract the response code"	code := ((resp copyUpTo: String cr) findTokens: ' ') second asNumber.	"And the response headers"	headers := Dictionary new.	resp lines allButFirst allButLast do:[:nextLine|		headers at: (nextLine copyUpTo: $:) asLowercase 			put: (nextLine copyAfter: $:) withBlanksTrimmed.	].	"Read response content"	contentLength := headers at: 'content-length' ifAbsent:[nil].	contentType := headers at: 'content-type' ifAbsent:['application/octet-stream'].	"Fixme - Provide HTTProgress"	contentLength 		ifNil:[contentStream := WriteStream with: stream upToEnd]		ifNotNil:[			contentLength := contentLength asNumber.			contentStream := (String new: contentLength) writeStream. 			[contentStream position < contentLength] whileTrue:[				contentStream nextPutAll: 					(stream next: (contentLength - contentStream position min: 4096)).				(HTTPProgress new) total: contentLength; 					amount: contentStream position; signal: 'Downloading...'.			].		].	stream close.	responseBlock ifNotNil:[responseBlock value: resp].	^(code between: 200 and: 299) 		ifTrue:[MIMEDocument contentType: contentType 				content: contentStream contents url: urlString]		ifFalse:[resp asString, contentStream contents].! !